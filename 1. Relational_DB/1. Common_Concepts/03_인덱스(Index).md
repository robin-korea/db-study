# [DB] 인덱스 (Index) 핵심 개념 정리

## 1. 인덱스(Index)란?

**정의:** 데이터베이스 테이블의 **검색(SELECT) 속도를 비약적으로 향상시키는 자료구조.**

-   **핵심 원리:** 책의 맨 뒤에 있는 '찾아보기'처럼, 데이터의 위치 정보를 미리 특정 순서로 정렬해서 저장해 둔다.
-   인덱스가 없으면, DB는 원하는 데이터를 찾기 위해 테이블의 모든 데이터를 처음부터 끝까지 하나씩 다 확인해야 한다(**Full Table Scan**).
-   인덱스를 사용하면, 정렬된 인덱스에서 데이터의 위치를 빠르게 찾은 뒤, 해당 위치로 바로 찾아가므로 검색 속도가 매우 빨라진다.

> **쉬운 예시: "책 찾아보기"**
> -   **인덱스 없는 경우:** '트랜잭션'이라는 단어를 찾기 위해 책 1페이지부터 마지막 페이지까지 한 장씩 다 넘겨본다.
> -   **인덱스 있는 경우:** 책 맨 뒤의 '찾아보기'에서 '트랜잭션'을 찾고, '253 페이지'라는 위치 정보를 얻은 뒤, 바로 253 페이지로 이동한다.

---

## 2. 인덱스의 자료구조: B-Tree

인덱스는 보통 **B-Tree (Balanced Tree)** 라는 자료구조로 만들어진다.

-   **특징:** 항상 균형을 유지하는 트리 구조로, 어떤 값을 찾더라도 비슷한 검색 속도를 보장한다. 대용량 데이터의 검색에 매우 효율적이다.
-   데이터를 항상 정렬된 상태로 유지하며, 특정 값을 찾을 때 트리의 루트(Root)에서부터 시작해 몇 번의 탐색만으로 원하는 데이터의 위치(주소)를 빠르게 찾아낸다.


---

## 3. 클러스터형 vs 비클러스터형 인덱스


### ① 클러스터형 인덱스 (Clustered Index)

-   **정의:** 테이블의 **실제 데이터 자체를 인덱스가 지정한 순서대로 물리적으로 정렬**하는 방식.
-   **특징:**
    -   테이블당 **하나만** 생성할 수 있다.
    -   책의 내용 자체가 가나다 순으로 정렬되어 있는 '영어 사전'과 같다.
    -   보통 테이블의 **기본키(Primary Key)**에 자동으로 생성된다.
-   **장점:** 특정 범위의 데이터를 함께 조회할 때 매우 빠르다.
-   **단점:** 데이터의 입력/수정/삭제 시, 데이터를 물리적으로 재정렬해야 하므로 비클러스터형에 비해 느리다.

### ② 비클러스터형 인덱스 (Non-Clustered Index)

-   **정의:** 실제 데이터는 그대로 두고, **데이터의 위치(주소) 정보만 별도의 공간에 정렬**해서 저장하는 방식.
-   **특징:**
    -   테이블당 **여러 개**를 생성할 수 있다.
    -   일반적인 책의 '찾아보기'와 같다. 책 내용은 페이지 순서대로 있고, 찾아보기는 따로 만들어진다.
-   **장점:** 데이터의 입력/수정/삭제가 클러스터형보다 빠르다.
-   **단점:** 데이터를 찾을 때 인덱스를 먼저 거쳐 실제 데이터 위치로 한 번 더 이동해야 하므로, 클러스터형보다 조회 속도는 약간 느릴 수 있다.

---

## 4. 인덱스의 장단점 (Trade-off)

| 장점 👍 | 단점 👎 |
| :--- | :--- |
| `SELECT` 쿼리의 성능을 크게 향상시킨다. (`WHERE`, `JOIN` 등) | `INSERT`, `UPDATE`, `DELETE` 쿼리의 성능은 **저하**된다. |
| | 데이터를 추가/수정/삭제할 때마다 인덱스 테이블도 함께 수정해야 하기 때문. |
| | 인덱스를 저장할 **추가적인 저장 공간**(보통 테이블 크기의 약 10%)이 필요하다. |

-   **결론:** 무분별하게 인덱스를 만드는 것은 오히려 전체적인 DB 성능을 떨어뜨릴 수 있다. **읽기(SELECT) 작업이 많고, 쓰기(INSERT/UPDATE/DELETE) 작업이 적은 컬럼**에 생성하는 것이 가장 효율적이다.
