# [DB] 정규화 (Normalization) 핵심 개념 정리

## 1. 정규화(Normalization)란?

**정의:** 데이터의 **중복을 최소화**하고, 데이터의 **일관성 및 무결성**을 높이기 위해 테이블 구조를 체계적으로 분리하는 과정.

### 정규화가 필요한 이유: '이상 현상(Anomaly)' 방지

정규화를 거치지 않은 테이블에서는 데이터를 다룰 때 다음과 같은 문제가 발생할 수 있다.

1.  **갱신 이상 (Update Anomaly):** 중복된 데이터 중 일부만 수정되어 데이터 불일치가 발생하는 문제.
2.  **삽입 이상 (Insertion Anomaly):** 불필요한 데이터가 없으면 새로운 데이터를 추가할 수 없는 문제.
3.  **삭제 이상 (Deletion Anomaly):** 데이터를 삭제했을 때, 의도치 않은 다른 정보까지 함께 삭제되는 문제.

---

## 2. 함수적 종속성 (Functional Dependency)

> 정규화의 모든 과정은 '함수적 종속성'을 파악하는 것에서 시작된다.

-   **정의:** 테이블에서 어떤 속성 A의 값을 알면, 다른 속성 B의 값이 유일하게 정해지는 관계.
-   **표기:** `A -> B` (B는 A에 함수적으로 종속된다)
-   **용어:**
    -   **결정자 (Determinant):** 다른 속성을 결정하는 속성 (A)
    -   **종속자 (Dependent):** 결정자에 의해 값이 정해지는 속성 (B)
-   **예시:** `학생` 테이블에서 `학번`을 알면 `이름`이 유일하게 정해진다.
    -   `학번` -> `이름`

---

## 3. 정규형의 종류

### 제1정규형 (1NF)

-   **조건:** 테이블의 모든 컬럼 값이 **원자값(Atomic Value)**을 가져야 한다. (하나의 칸에는 하나의 값만 존재)

### 제2정규형 (2NF)

-   **조건:** 제1정규형을 만족하고, **부분 함수 종속성**을 제거해야 한다.
-   **부분 함수 종속성:** 기본키가 여러 컬럼으로 구성된 '복합키'일 때, 키의 일부에만 종속되는 속성이 있는 경우.
    -   *예시: (`학번`, `과목코드`)가 기본키일 때, `성적`은 두 키에 모두 종속되지만, `과목명`은 `과목코드`에만 종속된다. 이때 `과목명`을 별도의 테이블로 분리해야 한다.*

### 제3정규형 (3NF)

-   **조건:** 제2정규형을 만족하고, **이행 함수 종속성**을 제거해야 한다.
-   **이행 함수 종속성:** 기본키가 아닌 일반 컬럼이 다른 일반 컬럼을 결정하는 경우. (`A -> B`, `B -> C` 관계)
    -   *예시: `학번` -> `학과코드`, `학과코드` -> `학과명` 관계가 있을 때, `학과명`을 별도의 `학과` 테이블로 분리해야 한다.*

### BCNF (Boyce-Codd 정규형)

-   **정의:** **"강화된 제3정규형"**. 3NF보다 더 엄격한 조건.
-   **조건:** 테이블의 **모든 결정자가 후보키(Candidate Key)**여야 한다. 3NF까지 만족해도 발생할 수 있는 일부 이상 현상을 해결한다.

---

## 4. 정규화의 장단점과 반정규화

### 정규화의 장단점

| 장점 👍 | 단점 👎 |
| :--- | :--- |
| 데이터 중복 최소화 | 테이블이 많아져 **JOIN 연산 증가** |
| 데이터 무결성 및 일관성 향상 | **조회(SELECT) 쿼리의 성능 저하** 가능성 |
| 유지보수 용이 | 쿼리가 더 복잡해짐 |

### 반정규화 (Denormalization, 역정규화)

-   **정의:** 조회 성능을 높이기 위해, 정규화 원칙을 위배하고 **의도적으로 테이블을 통합하거나 데이터를 중복시키는 것.**
-   **목적:** **JOIN 연산을 줄여** 쿼리 성능을 향상시키는 것이 주 목적.
-   **언제 사용하는가?:** 데이터의 수정/삭제보다 **조회(SELECT)가 압도적으로 많이 일어나는 시스템**에서 주로 사용된다.
